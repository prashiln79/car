<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>MQTT Car Control</title>
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<style>
body {
  font-family: Arial;
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; height: 100vh;
  background: linear-gradient(135deg, #e3f2fd, #bbdefb);
}
h2 { color: #333; margin-bottom: 20px; }
.controls {
  display: grid;
  grid-template-areas: ". forward ."
                       "left stop right"
                       ". backward .";
  gap: 15px;
}
#forward { grid-area: forward; }
#backward { grid-area: backward; }
#left { grid-area: left; }
#right { grid-area: right; }
#stop { grid-area: stop; }
button {
  width: 110px; height: 70px;
  font-size: 18px; border: none; border-radius: 12px;
  background-color: #4CAF50; color: white;
  box-shadow: 0 4px #388E3C; transition: 0.1s;
}
button:active { transform: translateY(3px); }
#stop { background-color: #f44336; }

.stage {
  position: relative;
  width: min(92vw, 560px); height: clamp(220px, 52vh, 420px);
  margin: 24px 0 8px;
  border-radius: 16px;
  background: #f5f5f5;
  box-shadow: inset 0 0 0 3px #e0e0e0, 0 8px 20px rgba(0,0,0,0.08);
  overflow: hidden;
}
.track {
  position: absolute; inset: 16px;
  border: 3px dashed #bdbdbd;
  border-radius: 12px;
}
.car {
  position: absolute;
  width: 56px; height: 32px;
  transform: translate(0px, 0px) rotate(0deg);
  transform-origin: 50% 50%;
}
.car-body {
  width: 100%; height: 100%;
  background: linear-gradient(180deg, #1976d2, #0d47a1);
  border-radius: 8px;
  box-shadow: 0 6px 12px rgba(13,71,161,0.35);
}
.wheel {
  position: absolute; width: 10px; height: 10px; background: #212121;
  border-radius: 50%; box-shadow: inset 0 0 0 2px #424242;
}
.wheel.front-left { top: -6px; left: 6px; }
.wheel.front-right { top: -6px; right: 6px; }
.wheel.back-left { bottom: -6px; left: 6px; }
.wheel.back-right { bottom: -6px; right: 6px; }
.hud {
  color: #333; font-size: 14px; margin-bottom: 10px;
}
.hint { color: #555; font-size: 13px; }

@media (max-width: 600px) {
  body { height: auto; padding: 12px; }
  h2 { font-size: 20px; margin-bottom: 12px; }
  .controls { gap: 10px; }
  button { width: 28vw; height: 60px; font-size: 16px; }
  #stop { width: 28vw; }
  .hud { font-size: 13px; }
  .hint { font-size: 12px; }
}
</style>
</head>
<body>
  <h2>ðŸš— MQTT WiFi Car Control</h2>
  <div class="hud">Use arrow keys or WASD to drive. Hold to move, release to stop.</div>
  <div class="stage" aria-label="car stage">
    <div class="track"></div>
    <div id="car" class="car">
      <div class="car-body"></div>
      <div class="wheel front-left"></div>
      <div class="wheel front-right"></div>
      <div class="wheel back-left"></div>
      <div class="wheel back-right"></div>
    </div>
  </div>
  <div class="controls">
    <button id="forward">Forward</button>
    <button id="backward">Backward</button>
    <button id="left">Left</button>
    <button id="right">Right</button>
    <button id="stop">Stop</button>
  </div>
  <div class="hint">Buttons and keyboard send MQTT commands to `car/control`.</div>

<script>
const options = {
  username: "Prashil",  
  password: "Prashil@n79", 
  clean: true,
  connectTimeout: 4000,
  reconnectPeriod: 2000
};

// Use WebSocket Secure port (8884)
const client = mqtt.connect("wss://f31f59e872194305880111b99a249d12.s1.eu.hivemq.cloud:8884/mqtt", options);

client.on("connect", () => {
  console.log("âœ… Connected to HiveMQ Cloud");
  client.subscribe("car/status", (err) => {
    if (!err) console.log("ðŸ“¡ Subscribed to car/status");
  });
});

client.on("message", (topic, message) => {
  console.log(`ðŸ“© ${topic}: ${message.toString()}`);
});

client.on("error", (err) => console.error("âŒ Connection error", err));

function send(cmd) {
  client.publish("car/control", cmd);
}

function stop() { send("stop"); }

["forward","backward","left","right","stop"].forEach(id=>{
 const b=document.getElementById(id);
 if(id==="stop"){b.onclick=stop;return;}
 b.onmousedown=()=>startMove(id); b.onmouseup=endMove; b.onmouseleave=endMove;
 b.ontouchstart=e=>{e.preventDefault();startMove(id);} 
 b.ontouchend=e=>{e.preventDefault();endMove();}
});

// Animation and keyboard controls
const carEl = document.getElementById("car");
const stageEl = document.querySelector(".stage");
const carW = 56, carH = 32, margin = 8;
let posX = 0; // will be centered on load
let posY = 0; // will be centered on load
let angleDeg = 0;
let reqId = null;
let activeDir = null; // "forward" | "backward" | "left" | "right" | null
const speed = 220; // px per second

function clamp(val, min, max){ return Math.max(min, Math.min(max, val)); }

function centerCar(){
  const w = stageEl.clientWidth;
  const h = stageEl.clientHeight;
  posX = (w - carW) / 2;
  posY = (h - carH) / 2;
  carEl.style.transform = `translate(${posX}px, ${posY}px) rotate(${angleDeg}deg)`;
}

function setDirection(dir){
  if(activeDir === dir) return;
  activeDir = dir;
  if(dir){
    const mqttMap = { forward: "backward", backward: "forward", left: "left", right: "right" };
    send(mqttMap[dir] || dir);
    if(dir==="forward") angleDeg = 180;
    if(dir==="backward") angleDeg = 0;
    if(dir==="left") angleDeg = -90;
    if(dir==="right") angleDeg = 90;
    loop();
  } else {
    stop();
    cancelAnim();
  }
}

function startMove(dir){ setDirection(dir); }
function endMove(){ setDirection(null); }

function cancelAnim(){ if(reqId){ cancelAnimationFrame(reqId); reqId = null; } }

let lastTs = 0;
function loop(ts){
  if(!activeDir){ cancelAnim(); return; }
  if(!ts) ts = performance.now();
  const dt = lastTs ? (ts - lastTs)/1000 : 0; // seconds
  lastTs = ts;

  let vx = 0, vy = 0;
  if(activeDir === "forward") { vy = 1; }
  if(activeDir === "backward") { vy = -1; }
  if(activeDir === "left") { vx = -1; }
  if(activeDir === "right") { vx = 1; }

  posX += vx * speed * dt;
  posY += vy * speed * dt;

  // bounds within stage inner area (approx considering car size)
  const maxX = stageEl.clientWidth - carW - margin;
  const maxY = stageEl.clientHeight - carH - margin;
  posX = clamp(posX, margin, maxX);
  posY = clamp(posY, margin, maxY);

  carEl.style.transform = `translate(${posX}px, ${posY}px) rotate(${angleDeg}deg)`;
  reqId = requestAnimationFrame(loop);
}

// Keyboard: Arrow keys + WASD
const keyToDir = {
  ArrowUp: "forward", KeyW: "forward",
  ArrowDown: "backward", KeyS: "backward",
  ArrowLeft: "left", KeyA: "left",
  ArrowRight: "right", KeyD: "right"
};

const downKeys = new Set();
window.addEventListener("keydown", (e)=>{
  const code = e.code in keyToDir ? e.code : e.key in keyToDir ? e.key : e.code;
  const dir = keyToDir[code] || keyToDir[e.key];
  if(!dir) return;
  e.preventDefault();
  if(downKeys.has(code)) return; // ignore repeats
  downKeys.add(code);
  setDirection(dir);
});

window.addEventListener("keyup", (e)=>{
  const code = e.code in keyToDir ? e.code : e.key in keyToDir ? e.key : e.code;
  if(downKeys.has(code)) downKeys.delete(code);
  // Determine next active direction from remaining keys
  for(const k of downKeys){
    const dir = keyToDir[k] || keyToDir[e.key];
    if(dir){ setDirection(dir); return; }
  }
  endMove();
});

// Initialize position and handle resize
window.addEventListener("load", ()=>{
  centerCar();
});
window.addEventListener("resize", ()=>{
  // If not moving, recenter; otherwise just clamp to new bounds
  if(!activeDir){ centerCar(); }
  else {
    const maxX = stageEl.clientWidth - carW - margin;
    const maxY = stageEl.clientHeight - carH - margin;
    posX = clamp(posX, margin, maxX);
    posY = clamp(posY, margin, maxY);
    carEl.style.transform = `translate(${posX}px, ${posY}px) rotate(${angleDeg}deg)`;
  }
});
</script>
</body>
</html>
