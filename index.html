<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>MQTT Car Control</title>
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<style>
body {
  font-family: Arial, sans-serif;
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; height: 100vh;
  background: linear-gradient(135deg, #e3f2fd, #bbdefb);
  margin: 0;
}
h2 { color: #333; margin-bottom: 10px; text-align: center; }

.hud {
  color: #333; font-size: 14px; margin-bottom: 15px; text-align: center;
}

.controls {
  display: grid;
  grid-template-areas:
    ". forward ."
    "left stop right"
    ". backward .";
  gap: 14px;
  justify-content: center;
  align-items: center;
}

#forward { grid-area: forward; }
#backward { grid-area: backward; }
#left { grid-area: left; }
#right { grid-area: right; }
#stop { grid-area: stop; }

button {
  width: 110px; height: 75px;
  font-size: 17px; font-weight: 600;
  border: none; border-radius: 16px;
  background-color: #4CAF50; color: white;
  box-shadow: 0 6px #388E3C;
  transition: 0.15s ease;
  touch-action: manipulation;
  user-select: none;
}
button:active { transform: scale(0.96); }
#stop { background-color: #f44336; box-shadow: 0 6px #c62828; }

.extra-controls {
  display: flex; gap: 10px; flex-wrap: wrap;
  justify-content: center; margin-top: 10px;
}

.extra-controls button {
  width: 120px; height: 60px;
  background-color: #2196f3;
  box-shadow: 0 5px #1565c0;
}

#lightToggle { background-color: #555; box-shadow: 0 5px #333; }
#lightToggle.active { background-color: #ff9800; box-shadow: 0 5px #f57c00; }
#gyroToggle { background-color: #9c27b0; box-shadow: 0 5px #6a1b9a; }
#gyroToggle.active { background-color: #4caf50; box-shadow: 0 5px #388e3c; }

.speed-control {
  margin-top: 18px; text-align: center;
}
.speed-control input { width: 220px; }
.speed-value { font-weight: 600; margin-top: 4px; color: #333; }

@media (max-width: 600px) {
  button { width: 28vw; height: 70px; font-size: 16px; }
  #stop { width: 28vw; }
}
</style>
</head>
<body>
  <h2>ðŸš— MQTT WiFi Car Control</h2>
  <div class="hud">Hold to move â€” combinations like Forward+Left are supported</div>

  <div class="controls">
    <button id="forward">Forward</button>
    <button id="backward">Backward</button>
    <button id="left">Left</button>
    <button id="right">Right</button>
    <button id="stop">Stop</button>
  </div>

  <div class="extra-controls">
    <button id="lightToggle">ðŸ’¤ Light Off</button>
    <button id="gyroToggle">ðŸ“± Enable Gyro</button>
  </div>

  <div class="speed-control">
    <label for="speed">Speed</label><br>
    <input type="range" id="speed" min="0" max="255" value="255">
    <div class="speed-value">Speed: <span id="speedVal">255</span></div>
  </div>

<script>
// ===== MQTT CONFIG =====
const options = {
  username: "Prashil",
  password: "Prashil@n79",
  clean: true,
  connectTimeout: 4000,
  reconnectPeriod: 2000
};
const client = mqtt.connect("wss://f31f59e872194305880111b99a249d12.s1.eu.hivemq.cloud:8884/mqtt", options);

client.on("connect", () => {
  console.log("âœ… Connected to HiveMQ Cloud");
  client.subscribe("car/status");
});
client.on("message", (topic, message) => console.log(`ðŸ“© ${topic}: ${message.toString()}`));

// ===== COMMAND SYSTEM =====
let pressed = new Set();

function vibrate(ms) { if (navigator.vibrate) navigator.vibrate(ms); }
function send(cmd) { console.log("ðŸš€ Sending:", cmd); client.publish("car/control", cmd); }

function stop() { send("stop"); }

// Determine motion based on active pressed keys/buttons
function evaluateMotion() {
  let cmd = "";
  const f = pressed.has("forward");
  const b = pressed.has("backward");
  const l = pressed.has("left");
  const r = pressed.has("right");

  if (f && l) cmd = "backward_left";
  else if (f && r) cmd = "backward_right";
  else if (b && l) cmd = "forward_left";
  else if (b && r) cmd = "forward_right";
  else if (f) cmd = "backward";
  else if (b) cmd = "forward";
  else if (l) cmd = "left";
  else if (r) cmd = "right";
  else cmd = "stop";

  send(cmd);
}

// ===== BUTTON CONTROLS =====
["forward","backward","left","right"].forEach(id => {
  const btn = document.getElementById(id);

  // Mouse controls
  btn.onmousedown = () => { pressed.add(id); evaluateMotion(); };
  btn.onmouseup = () => { pressed.delete(id); evaluateMotion(); };
  btn.onmouseleave = () => { pressed.delete(id); evaluateMotion(); };

  // Touch controls
  btn.ontouchstart = e => { e.preventDefault(); pressed.add(id); evaluateMotion(); };
  btn.ontouchend = e => { e.preventDefault(); pressed.delete(id); evaluateMotion(); };
});

document.getElementById("stop").onclick = () => { pressed.clear(); stop(); };

// ===== LIGHT CONTROLS =====
let lightOn = false;
const lightToggleBtn = document.getElementById("lightToggle");

lightToggleBtn.onclick = () => {
  lightOn = !lightOn;
  if (lightOn) {
    lightToggleBtn.textContent = "ðŸ’¡ Light On";
    lightToggleBtn.classList.add("active");
    send("light_on");
  } else {
    lightToggleBtn.textContent = "ðŸ’¤ Light Off";
    lightToggleBtn.classList.remove("active");
    send("light_off");
  }
};

// ===== SPEED CONTROL =====
const speedSlider = document.getElementById("speed");
const speedVal = document.getElementById("speedVal");
speedSlider.oninput = () => {
  speedVal.textContent = speedSlider.value;
  send(`speed:${speedSlider.value}`);
};

// ===== KEYBOARD SUPPORT =====
const keyMap = {
  ArrowUp: "forward", KeyW: "forward",
  ArrowDown: "backward", KeyS: "backward",
  ArrowLeft: "left", KeyA: "left",
  ArrowRight: "right", KeyD: "right"
};

document.addEventListener("keydown", e => {
  const cmd = keyMap[e.code];
  if (!cmd) return;
  if (!pressed.has(cmd)) { pressed.add(cmd); evaluateMotion(); }
});
document.addEventListener("keyup", e => {
  const cmd = keyMap[e.code];
  if (cmd && pressed.has(cmd)) { pressed.delete(cmd); evaluateMotion(); }
});

// ===== GYROSCOPE CONTROL =====
let gyroEnabled = false;
let gyroPressed = new Set();
const gyroThreshold = 15; // degrees of tilt to trigger movement
const gyroDeadzone = 5; // deadzone to prevent drift

const gyroToggleBtn = document.getElementById("gyroToggle");

function updateGyroButton() {
  if (gyroEnabled) {
    gyroToggleBtn.textContent = "ðŸ“± Disable Gyro";
    gyroToggleBtn.classList.add("active");
  } else {
    gyroToggleBtn.textContent = "ðŸ“± Enable Gyro";
    gyroToggleBtn.classList.remove("active");
    // Clear gyro-based pressed keys when disabled
    gyroPressed.forEach(key => pressed.delete(key));
    gyroPressed.clear();
    evaluateMotion();
  }
}

gyroToggleBtn.onclick = () => {
  if (!gyroEnabled) {
    // Request permission for DeviceOrientationEvent (iOS 13+)
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission()
        .then(response => {
          if (response === 'granted') {
            gyroEnabled = true;
            updateGyroButton();
            startGyro();
          } else {
            alert("Gyroscope permission denied. Please enable it in settings.");
          }
        })
        .catch(err => console.error("Error requesting gyro permission:", err));
    } else {
      // Android/other browsers
      gyroEnabled = true;
      updateGyroButton();
      startGyro();
    }
  } else {
    gyroEnabled = false;
    updateGyroButton();
    stopGyro();
  }
};

function startGyro() {
  window.addEventListener("deviceorientation", handleOrientation);
}

function stopGyro() {
  window.removeEventListener("deviceorientation", handleOrientation);
}

function handleOrientation(event) {
  if (!gyroEnabled) return;

  const beta = event.beta; // front-back tilt (-180 to 180)
  const gamma = event.gamma; // left-right tilt (-90 to 90)

  // Clear previous gyro-based commands
  gyroPressed.forEach(key => pressed.delete(key));
  gyroPressed.clear();

  // Forward/Backward based on beta (front-back tilt)
  if (beta > gyroThreshold + gyroDeadzone) {
    gyroPressed.add("backward");
    pressed.add("backward");
  } else if (beta < -gyroThreshold - gyroDeadzone) {
    gyroPressed.add("forward");
    pressed.add("forward");
  }

  // Left/Right based on gamma (left-right tilt)
  if (gamma > gyroThreshold + gyroDeadzone) {
    gyroPressed.add("right");
    pressed.add("right");
  } else if (gamma < -gyroThreshold - gyroDeadzone) {
    gyroPressed.add("left");
    pressed.add("left");
  }

  // Update motion based on current state
  evaluateMotion();
}

updateGyroButton();
</script>
</body>
</html>
