<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>MQTT Car Control</title>
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.1/dist/nipplejs.min.js"></script>
<style>
body {
  font-family: Arial, sans-serif;
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; height: 100vh;
  background: linear-gradient(135deg, #e3f2fd, #bbdefb);
  margin: 0;
}
h2 { color: #333; margin-bottom: 10px; text-align: center; }

.hud {
  color: #333; font-size: 14px; margin-bottom: 15px; text-align: center;
}

.controls {
  display: grid;
  grid-template-areas:
    ". forward ."
    "left stop right"
    ". backward .";
  gap: 14px;
  justify-content: center;
  align-items: center;
}

#forward { grid-area: forward; }
#backward { grid-area: backward; }
#left { grid-area: left; }
#right { grid-area: right; }
#stop { grid-area: stop; }

button {
  width: 110px; height: 75px;
  font-size: 17px; font-weight: 600;
  border: none; border-radius: 16px;
  background-color: #4CAF50; color: white;
  box-shadow: 0 6px #388E3C;
  transition: 0.15s ease;
  touch-action: manipulation;
  user-select: none;
}
button:active { transform: scale(0.96); }
#stop { background-color: #f44336; box-shadow: 0 6px #c62828; }

.extra-controls {
  display: flex; gap: 10px; flex-wrap: wrap;
  justify-content: center; margin-top: 10px;
}

.extra-controls button {
  width: 120px; height: 60px;
  background-color: #2196f3;
  box-shadow: 0 5px #1565c0;
}

#lightToggle { background-color: #555; box-shadow: 0 5px #333; }
#lightToggle.active { background-color: #ff9800; box-shadow: 0 5px #f57c00; }
#gyroToggle { background-color: #9c27b0; box-shadow: 0 5px #6a1b9a; }
#gyroToggle.active { background-color: #4caf50; box-shadow: 0 5px #388e3c; }

.speed-control {
  margin-top: 18px; text-align: center;
}
.speed-control input { width: 220px; }
.speed-value { font-weight: 600; margin-top: 4px; color: #333; }

.joystick-container {
  margin-top: 20px;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
}

#joystick-zone {
  width: 200px;
  height: 200px;
  position: relative;
  background: rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border: 2px solid rgba(0, 0, 0, 0.1);
}

.joystick-directions {
  position: absolute;
  width: 200px;
  height: 200px;
  top: 0;
  left: 0;
  pointer-events: none;
}

.direction-label {
  position: absolute;
  font-size: 18px;
  font-weight: bold;
  color: rgba(76, 175, 80, 0.7);
  text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
  transition: color 0.2s, transform 0.2s;
}

.direction-label.active {
  color: #4CAF50;
  text-shadow: 2px 2px 4px rgba(76, 175, 80, 0.5);
}

.direction-label.forward { 
  top: 5px; 
  left: 50%; 
  transform: translateX(-50%);
}
.direction-label.forward.active { 
  transform: translateX(-50%) scale(1.3);
}

.direction-label.backward { 
  bottom: 5px; 
  left: 50%; 
  transform: translateX(-50%);
}
.direction-label.backward.active { 
  transform: translateX(-50%) scale(1.3);
}

.direction-label.left { 
  left: 5px; 
  top: 50%; 
  transform: translateY(-50%);
}
.direction-label.left.active { 
  transform: translateY(-50%) scale(1.3);
}

.direction-label.right { 
  right: 5px; 
  top: 50%; 
  transform: translateY(-50%);
}
.direction-label.right.active { 
  transform: translateY(-50%) scale(1.3);
}

.direction-indicator {
  position: absolute;
  width: 200px;
  height: 200px;
  top: 0;
  left: 0;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s;
}

.direction-indicator.active {
  opacity: 1;
}

.direction-arrow {
  position: absolute;
  width: 0;
  height: 0;
  border-style: solid;
}

.arrow-forward {
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  border-left: 8px solid transparent;
  border-right: 8px solid transparent;
  border-bottom: 15px solid #4CAF50;
}

.arrow-backward {
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  border-left: 8px solid transparent;
  border-right: 8px solid transparent;
  border-top: 15px solid #4CAF50;
}

.arrow-left {
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  border-top: 8px solid transparent;
  border-bottom: 8px solid transparent;
  border-right: 15px solid #4CAF50;
}

.arrow-right {
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  border-top: 8px solid transparent;
  border-bottom: 8px solid transparent;
  border-left: 15px solid #4CAF50;
}

.joystick-label {
  text-align: center;
  margin-top: 10px;
  color: #333;
  font-size: 14px;
  font-weight: 600;
}

.orientation-info {
  text-align: center;
  margin-top: 5px;
  color: #666;
  font-size: 12px;
}

@media (max-width: 600px) {
  button { width: 28vw; height: 70px; font-size: 16px; }
  #stop { width: 28vw; }
}
</style>
</head>
<body>
  <h2>üöó MQTT WiFi Car Control</h2>
  <div class="hud">Hold to move ‚Äî combinations like Forward+Left are supported</div>

  <div class="controls">
    <button id="forward">Forward</button>
    <button id="backward">Backward</button>
    <button id="left">Left</button>
    <button id="right">Right</button>
    <button id="stop">Stop</button>
  </div>

  <div class="extra-controls">
    <button id="lightToggle">üí§ Light Off</button>
    <button id="gyroToggle">üì± Enable Gyro</button>
  </div>

  <div class="speed-control">
    <label for="speed">Speed</label><br>
    <input type="range" id="speed" min="0" max="255" value="255">
    <div class="speed-value">Speed: <span id="speedVal">255</span></div>
  </div>

  <div class="joystick-container">
    <div>
      <div id="joystick-zone">
        <div class="joystick-directions">
          <div class="direction-label forward">‚Üë</div>
          <div class="direction-label backward">‚Üì</div>
          <div class="direction-label left">‚Üê</div>
          <div class="direction-label right">‚Üí</div>
        </div>
        <div class="direction-indicator" id="direction-indicator">
          <div class="direction-arrow arrow-forward"></div>
          <div class="direction-arrow arrow-backward"></div>
          <div class="direction-arrow arrow-left"></div>
          <div class="direction-arrow arrow-right"></div>
        </div>
      </div>
      <div class="joystick-label">Virtual Joystick</div>
      <div class="orientation-info" id="orientation-info">Portrait</div>
    </div>
  </div>

<script>
// ===== MQTT CONFIG =====
const options = {
  username: "Prashil",
  password: "Prashil@n79",
  clean: true,
  connectTimeout: 4000,
  reconnectPeriod: 2000
};
const client = mqtt.connect("wss://f31f59e872194305880111b99a249d12.s1.eu.hivemq.cloud:8884/mqtt", options);

client.on("connect", () => {
  console.log("‚úÖ Connected to HiveMQ Cloud");
  client.subscribe("car/status");
});
client.on("message", (topic, message) => console.log(`üì© ${topic}: ${message.toString()}`));

// ===== COMMAND SYSTEM =====
let pressed = new Set();

function vibrate(ms) { if (navigator.vibrate) navigator.vibrate(ms); }
function send(cmd) { console.log("üöÄ Sending:", cmd); client.publish("car/control", cmd); }

function stop() { send("stop"); }

// Determine motion based on active pressed keys/buttons
function evaluateMotion() {
  let cmd = "";
  const f = pressed.has("forward");
  const b = pressed.has("backward");
  const l = pressed.has("left");
  const r = pressed.has("right");

  if (f && l) cmd = "backward_left";
  else if (f && r) cmd = "backward_right";
  else if (b && l) cmd = "forward_left";
  else if (b && r) cmd = "forward_right";
  else if (f) cmd = "backward";
  else if (b) cmd = "forward";
  else if (l) cmd = "left";
  else if (r) cmd = "right";
  else cmd = "stop";

  send(cmd);
}

// ===== BUTTON CONTROLS =====
["forward","backward","left","right"].forEach(id => {
  const btn = document.getElementById(id);

  // Mouse controls
  btn.onmousedown = () => { pressed.add(id); evaluateMotion(); };
  btn.onmouseup = () => { pressed.delete(id); evaluateMotion(); };
  btn.onmouseleave = () => { pressed.delete(id); evaluateMotion(); };

  // Touch controls
  btn.ontouchstart = e => { e.preventDefault(); pressed.add(id); evaluateMotion(); };
  btn.ontouchend = e => { e.preventDefault(); pressed.delete(id); evaluateMotion(); };
});

document.getElementById("stop").onclick = () => { pressed.clear(); stop(); };

// ===== LIGHT CONTROLS =====
let lightOn = false;
const lightToggleBtn = document.getElementById("lightToggle");

lightToggleBtn.onclick = () => {
  lightOn = !lightOn;
  if (lightOn) {
    lightToggleBtn.textContent = "üí° Light On";
    lightToggleBtn.classList.add("active");
    send("light_on");
  } else {
    lightToggleBtn.textContent = "üí§ Light Off";
    lightToggleBtn.classList.remove("active");
    send("light_off");
  }
};

// ===== SPEED CONTROL =====
const speedSlider = document.getElementById("speed");
const speedVal = document.getElementById("speedVal");
speedSlider.oninput = () => {
  speedVal.textContent = speedSlider.value;
  send(`speed:${speedSlider.value}`);
};

// ===== KEYBOARD SUPPORT =====
const keyMap = {
  ArrowUp: "forward", KeyW: "forward",
  ArrowDown: "backward", KeyS: "backward",
  ArrowLeft: "left", KeyA: "left",
  ArrowRight: "right", KeyD: "right"
};

document.addEventListener("keydown", e => {
  const cmd = keyMap[e.code];
  if (!cmd) return;
  if (!pressed.has(cmd)) { pressed.add(cmd); evaluateMotion(); }
});
document.addEventListener("keyup", e => {
  const cmd = keyMap[e.code];
  if (cmd && pressed.has(cmd)) { pressed.delete(cmd); evaluateMotion(); }
});

// ===== JOYSTICK CONTROL =====
let joystickPressed = new Set();
let joystickManager = null;
let deviceOrientation = 0; // 0, 90, 180, 270 degrees

// Get device orientation
function getDeviceOrientation() {
  let orientation = 0;
  
  if (screen.orientation && screen.orientation.angle !== undefined) {
    // Modern API: returns 0, 90, 180, 270
    orientation = screen.orientation.angle;
  } else if (window.orientation !== undefined) {
    // Legacy API: returns 0, 90, -90, 180
    orientation = window.orientation;
    // Convert -90 to 270 for consistency
    if (orientation < 0) orientation += 360;
  }
  
  return orientation;
}

// Update orientation info display
function updateOrientationInfo() {
  const orientation = getDeviceOrientation();
  const infoEl = document.getElementById("orientation-info");
  let orientationText = "";
  
  if (orientation === 0 || orientation === 180) {
    orientationText = "Portrait";
  } else {
    orientationText = "Landscape";
  }
  
  infoEl.textContent = `${orientationText} (${orientation}¬∞)`;
  deviceOrientation = orientation;
}

// Adjust angle based on device orientation
function adjustAngleForOrientation(angle) {
  // nipplejs gives angle relative to screen (0¬∞ = top of screen)
  // We want angle relative to device physical orientation (0¬∞ = top of device)
  // When device rotates clockwise, screen rotates counter-clockwise relative to device
  // So we subtract the orientation to compensate
  let adjustedAngle = angle - deviceOrientation;
  
  // Normalize to 0-360 range
  while (adjustedAngle < 0) adjustedAngle += 360;
  while (adjustedAngle >= 360) adjustedAngle -= 360;
  
  return adjustedAngle;
}

// Update visual direction indicators
function updateDirectionIndicators(directions) {
  const labels = document.querySelectorAll('.direction-label');
  labels.forEach(label => {
    label.classList.remove('active');
  });
  
  if (directions.has('forward')) {
    document.querySelector('.direction-label.forward').classList.add('active');
  }
  if (directions.has('backward')) {
    document.querySelector('.direction-label.backward').classList.add('active');
  }
  if (directions.has('left')) {
    document.querySelector('.direction-label.left').classList.add('active');
  }
  if (directions.has('right')) {
    document.querySelector('.direction-label.right').classList.add('active');
  }
  
  // Show/hide direction indicator overlay
  const indicator = document.getElementById('direction-indicator');
  if (directions.size > 0) {
    indicator.classList.add('active');
  } else {
    indicator.classList.remove('active');
  }
}

function initJoystick() {
  const zone = document.getElementById("joystick-zone");
  joystickManager = nipplejs.create({
    zone: zone,
    mode: 'static',
    position: { left: '50%', top: '50%' },
    color: '#4CAF50',
    size: 120,
    threshold: 0.1,
    fadeTime: 250
  });

  joystickManager.on('start', () => {
    console.log("üéÆ Joystick started");
    vibrate(50);
  });

  joystickManager.on('move', (evt, data) => {
    // Clear previous joystick-based commands
    joystickPressed.forEach(key => pressed.delete(key));
    joystickPressed.clear();

    const rawAngle = data.angle.degree;
    const force = data.force;
    
    // Adjust angle for device orientation
    const angle = adjustAngleForOrientation(rawAngle);

    // Only trigger movement if force is significant
    if (force > 0.3) {
      // Determine direction based on angle (0¬∞ = up/north, clockwise)
      // Forward/Backward: 0¬∞ = forward, 180¬∞ = backward
      // Left/Right: 90¬∞ = right, 270¬∞ = left
      // Using expanded ranges to allow diagonal movements
      // NOTE: Forward/Backward swapped with Left/Right
      
      // Right: covers 315¬∞-45¬∞ (wrapping around) - overlaps with forward/backward for diagonals
      if (angle >= 315 || angle <= 45) {
        joystickPressed.add("right");
        pressed.add("right");
      }
      // Left: covers 135¬∞-225¬∞ - overlaps with forward/backward for diagonals
      if (angle >= 135 && angle <= 225) {
        joystickPressed.add("left");
        pressed.add("left");
      }

      // Forward: covers 45¬∞-135¬∞ - overlaps with left/right for diagonals
      if (angle >= 45 && angle <= 135) {
        joystickPressed.add("forward");
        pressed.add("forward");
      }
      // Backward: covers 225¬∞-315¬∞ - overlaps with left/right for diagonals
      if (angle >= 225 && angle <= 315) {
        joystickPressed.add("backward");
        pressed.add("backward");
      }
    }

    // Update visual indicators
    updateDirectionIndicators(joystickPressed);
    
    evaluateMotion();
  });

  joystickManager.on('end', () => {
    console.log("üéÆ Joystick released");
    vibrate(30);
    // Clear joystick-based commands
    joystickPressed.forEach(key => pressed.delete(key));
    joystickPressed.clear();
    updateDirectionIndicators(new Set());
    evaluateMotion();
  });
}

// Initialize joystick when page loads
initJoystick();

// Handle orientation changes
updateOrientationInfo();
window.addEventListener('orientationchange', () => {
  setTimeout(updateOrientationInfo, 100);
});
window.addEventListener('resize', () => {
  setTimeout(updateOrientationInfo, 100);
});

// Also listen for screen orientation API if available
if (screen.orientation) {
  screen.orientation.addEventListener('change', updateOrientationInfo);
}

// ===== GYROSCOPE CONTROL =====
let gyroEnabled = false;
let gyroPressed = new Set();
const gyroThreshold = 15; // degrees of tilt to trigger movement
const gyroDeadzone = 5; // deadzone to prevent drift

const gyroToggleBtn = document.getElementById("gyroToggle");

function updateGyroButton() {
  if (gyroEnabled) {
    gyroToggleBtn.textContent = "üì± Disable Gyro";
    gyroToggleBtn.classList.add("active");
  } else {
    gyroToggleBtn.textContent = "üì± Enable Gyro";
    gyroToggleBtn.classList.remove("active");
    // Clear gyro-based pressed keys when disabled
    gyroPressed.forEach(key => pressed.delete(key));
    gyroPressed.clear();
    evaluateMotion();
  }
}

gyroToggleBtn.onclick = () => {
  if (!gyroEnabled) {
    // Request permission for DeviceOrientationEvent (iOS 13+)
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission()
        .then(response => {
          if (response === 'granted') {
            gyroEnabled = true;
            updateGyroButton();
            startGyro();
          } else {
            alert("Gyroscope permission denied. Please enable it in settings.");
          }
        })
        .catch(err => console.error("Error requesting gyro permission:", err));
    } else {
      // Android/other browsers
      gyroEnabled = true;
      updateGyroButton();
      startGyro();
    }
  } else {
    gyroEnabled = false;
    updateGyroButton();
    stopGyro();
  }
};

function startGyro() {
  window.addEventListener("deviceorientation", handleOrientation);
}

function stopGyro() {
  window.removeEventListener("deviceorientation", handleOrientation);
}

function handleOrientation(event) {
  if (!gyroEnabled) return;

  const beta = event.beta; // front-back tilt (-180 to 180)
  const gamma = event.gamma; // left-right tilt (-90 to 90)

  // Clear previous gyro-based commands
  gyroPressed.forEach(key => pressed.delete(key));
  gyroPressed.clear();

  // Forward/Backward based on beta (front-back tilt)
  if (beta > gyroThreshold + gyroDeadzone) {
    gyroPressed.add("backward");
    pressed.add("backward");
  } else if (beta < -gyroThreshold - gyroDeadzone) {
    gyroPressed.add("forward");
    pressed.add("forward");
  }

  // Left/Right based on gamma (left-right tilt)
  if (gamma > gyroThreshold + gyroDeadzone) {
    gyroPressed.add("right");
    pressed.add("right");
  } else if (gamma < -gyroThreshold - gyroDeadzone) {
    gyroPressed.add("left");
    pressed.add("left");
  }

  // Update motion based on current state
  evaluateMotion();
}

updateGyroButton();
</script>
</body>
</html>
