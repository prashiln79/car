<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MQTT Car Control â€” Dual Joystick PWM</title>

<!-- libs -->
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.1/dist/nipplejs.min.js"></script>

<style>
  :root{
    --bg-a: #e3f2fd;
    --bg-b: #bbdefb;
    --btn:#4CAF50;
    --btn-press:#388E3C;
    --accent:#2196f3;
    --danger:#f44336;
    --glass: rgba(255,255,255,0.6);
  }
  html,body{height:100%;margin:0;font-family:Inter, system-ui, Arial, sans-serif;}
  body{
    display:flex;align-items:center;justify-content:center;
    background: linear-gradient(135deg,var(--bg-a),var(--bg-b));
    padding:18px;
  }

  .card{
    width:100%; max-width:980px; background:linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.65));
    border-radius:16px; padding:18px; box-shadow:0 12px 30px rgba(12,30,60,0.12);
  }

  header{display:flex;align-items:center;gap:12px;}
  header h1{margin:0;font-size:20px;color:#212121;}
  header p{margin:0;color:#424242;font-size:13px;}

  .top-row{display:flex;gap:14px;margin-top:14px;flex-wrap:wrap;align-items:center;}
  .controls {
    display: grid;
    grid-template-areas:
      ". forward ."
      "left stop right"
      ". backward .";
    gap: 12px;
    align-items:center;
  }
  #forward { grid-area: forward; }
  #backward { grid-area: backward; }
  #left { grid-area: left; }
  #right { grid-area: right; }
  #stop { grid-area: stop; }

  button {
    width: 110px; height: 70px;
    border: none; border-radius: 12px;
    font-size: 15px; font-weight: 700;
    color: white; background: var(--btn);
    box-shadow: 0 5px var(--btn-press);
    transition: transform .08s ease, box-shadow .08s;
    user-select: none;
    touch-action: manipulation;
  }
  button:active{ transform: translateY(2px) scale(.99); box-shadow:0 3px var(--btn-press); }
  #stop { background: var(--danger); box-shadow:0 5px #c62828; width:120px; }
  .extra-controls{ display:flex; gap:10px; flex-wrap:wrap; margin-left:12px; }
  .extra-controls button{ width:140px; height:50px; background:var(--accent); box-shadow:0 5px #1565c0; border-radius:10px; font-weight:700; color:#fff; }
  .toggle-on{ background:#4caf50 !important; box-shadow:0 5px #388e3c !important; }
  .toggle-warning{ background:#ff9800 !important; box-shadow:0 5px #f57c00 !important; }

  .speed-panel { margin-top:14px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .speed-panel label{ font-weight:700; color:#333; }
  .speed-panel input[type=range]{ width:260px; }

  .joystick-row{ display:flex; gap:32px; margin-top:18px; align-items:flex-start; justify-content:center; flex-wrap:wrap;}
  .joystick-zone{
    width:160px; height:160px; border-radius:50%; background:var(--glass);
    display:flex; align-items:center; justify-content:center; position:relative; border:2px solid rgba(0,0,0,0.06);
  }
  .joystick-label{ text-align:center; margin-top:8px; color:#333; font-weight:600; }

  .status-bar{ margin-top:14px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .status-pill{ padding:8px 12px; border-radius:999px; background:#fff; box-shadow:0 6px 18px rgba(10,20,40,0.06); font-weight:700; color:#333; font-size:13px; }

  @media (max-width:640px){
    .joystick-zone{ width:120px; height:120px; }
    button{ width:44vw; height:64px; font-size:15px; }
    #stop{ width:48vw; }
  }
</style>
</head>
<body>
  <div class="card">
    <header>
      <div>
        <h1>ðŸš— MQTT Car Control â€” Dual Joysticks (PWM)</h1>
        <p>Left: throttle â€” Right: steering. Publishes smooth PWM JSON to <code>car/speed</code></p>
      </div>
      <div style="margin-left:auto">
        <div class="status-pill" id="connStatus">Connecting...</div>
      </div>
    </header>

    <div class="top-row">
      <div class="controls" id="buttonControls" aria-hidden="false">
        <button id="forward">Forward</button>
        <button id="backward">Backward</button>
        <button id="left">Left</button>
        <button id="right">Right</button>
        <button id="stop">Stop</button>
      </div>

      <div class="extra-controls" style="margin-left:auto">
        <button id="modeToggle">ðŸŽ® Joystick Mode</button>
        <button id="lightToggle">ðŸ’¤ Light Off</button>
        <button id="killAll">â›” Emergency Stop</button>
      </div>
    </div>

    <div class="speed-panel">
      <label for="speedLimit">Max Speed</label>
      <input id="speedLimit" type="range" min="0" max="255" value="255" />
      <div class="status-pill">Limit: <span id="speedLimitVal">255</span></div>
      <div class="status-pill">Left PWM: <span id="leftPWM">0</span></div>
      <div class="status-pill">Right PWM: <span id="rightPWM">0</span></div>
    </div>

    <div class="joystick-row" id="joystickArea" style="display:none">
      <div>
        <div id="joystick-left" class="joystick-zone"></div>
        <div class="joystick-label">Throttle</div>
      </div>
      <div>
        <div id="joystick-right" class="joystick-zone"></div>
        <div class="joystick-label">Steering</div>
      </div>
    </div>

    <div class="status-bar">
      <div class="status-pill">MQTT: <span id="mqttState">â€”</span></div>
      <div class="status-pill">Publishing topic: <code>car/speed</code></div>
      <div class="status-pill">Format: JSON {left,right,leftDir,rightDir}</div>
    </div>
  </div>

<script>
/* ============================
   MQTT â€” HiveMQ WebSocket
   ============================ */
const mqttUrl = "wss://f31f59e872194305880111b99a249d12.s1.eu.hivemq.cloud:8884/mqtt";
const mqttOpts = {
  username: "Prashil",
  password: "Prashil@n79",
  connectTimeout: 4000,
  reconnectPeriod: 2000,
  clean: true
};
const client = mqtt.connect(mqttUrl, mqttOpts);

/* UI elements */
const connStatus = document.getElementById('connStatus');
const mqttState = document.getElementById('mqttState');
const leftPWMTxt = document.getElementById('leftPWM');
const rightPWMTxt = document.getElementById('rightPWM');
const speedLimitInput = document.getElementById('speedLimit');
const speedLimitVal = document.getElementById('speedLimitVal');

client.on('connect', () => {
  connStatus.textContent = 'Connected';
  mqttState.textContent = 'connected';
  connStatus.style.background = '#e8f5e9';
  connStatus.style.color = '#256029';
  // subscribe if you want to receive replies
  client.subscribe('car/status');
});
client.on('reconnect', () => {
  connStatus.textContent = 'Reconnecting...';
  mqttState.textContent = 'reconnecting';
});
client.on('error', err => {
  console.error('MQTT error', err);
  connStatus.textContent = 'MQTT Error';
  mqttState.textContent = 'error';
});
client.on('close', () => {
  connStatus.textContent = 'Disconnected';
  mqttState.textContent = 'disconnected';
});

/* helper to publish car/control commands (buttons) */
function publishControl(cmd){
  if(client && client.connected) client.publish('car/control', cmd);
  console.log('PUB car/control ->', cmd);
}

/* ============================
   Button controls (retain)
   ============================ */
const pressed = new Set();
const keyMap = { ArrowUp:"forward",KeyW:"forward",ArrowDown:"backward",KeyS:"backward",ArrowLeft:"left",KeyA:"left",ArrowRight:"right",KeyD:"right" };

document.addEventListener('keydown', e => {
  const cmd = keyMap[e.code];
  if(!cmd) return;
  if(!pressed.has(cmd)){ pressed.add(cmd); evaluateButtons(); }
});
document.addEventListener('keyup', e => {
  const cmd = keyMap[e.code]; if(cmd){ pressed.delete(cmd); evaluateButtons(); }
});

function evaluateButtons(){
  if(pressed.size===0) { publishControl('stop'); return; }
  if(pressed.has('forward') && pressed.has('left')) publishControl('forward_left');
  else if(pressed.has('forward') && pressed.has('right')) publishControl('forward_right');
  else if(pressed.has('backward') && pressed.has('left')) publishControl('backward_left');
  else if(pressed.has('backward') && pressed.has('right')) publishControl('backward_right');
  else if(pressed.has('forward')) publishControl('forward');
  else if(pressed.has('backward')) publishControl('backward');
  else if(pressed.has('left')) publishControl('left');
  else if(pressed.has('right')) publishControl('right');
}

/* map button events */
['forward','backward','left','right'].forEach(id=>{
  const btn = document.getElementById(id);
  btn.addEventListener('touchstart', e=>{ e.preventDefault(); pressed.add(id); evaluateButtons(); }, {passive:false});
  btn.addEventListener('mousedown', e=>{ e.preventDefault(); pressed.add(id); evaluateButtons(); });
  ['touchend','mouseup','mouseleave'].forEach(ev=> btn.addEventListener(ev, e=>{ e.preventDefault(); pressed.delete(id); evaluateButtons(); }, {passive:false}));
});
document.getElementById('stop').addEventListener('click', ()=>{ pressed.clear(); publishControl('stop'); });

/* light toggle */
let lightOn = false;
const lightBtn = document.getElementById('lightToggle');
lightBtn.addEventListener('click', ()=>{
  lightOn = !lightOn;
  lightBtn.textContent = lightOn ? 'ðŸ’¡ Light On' : 'ðŸ’¤ Light Off';
  lightBtn.classList.toggle('toggle-warning', lightOn);
  publishControl(lightOn ? 'light_on' : 'light_off');
});

/* emergency kill */
document.getElementById('killAll').addEventListener('click', ()=>{
  // Send MQTT stop and also pwm zero for safety
  publishControl('stop');
  sendPWMPayload(0,0,0,0,true); // force publish immediate stop
});

/* ============================
   Joysticks (nipplejs)
   - left: throttle (vertical)
   - right: steering (horizontal)
   - produce left/right motor PWM in -255..255
   - publish JSON to 'car/speed'
   - smoothing applied
   ============================ */

const modeToggle = document.getElementById('modeToggle');
const joystickArea = document.getElementById('joystickArea');
const buttonControls = document.getElementById('buttonControls');

let joystickLeft = null, joystickRight = null;
let joystickActive = false;

modeToggle.addEventListener('click', ()=>{
  joystickActive = !joystickActive;
  modeToggle.textContent = joystickActive ? 'ðŸ•¹ Button Mode' : 'ðŸŽ® Joystick Mode';
  modeToggle.classList.toggle('toggle-on', joystickActive);
  joystickArea.style.display = joystickActive ? 'flex' : 'none';
  buttonControls.style.display = joystickActive ? 'none' : 'grid';
  if(joystickActive) initJoysticks();
  else { /* on disabling joystick ensure we stop motors smoothly */ setJoystickTargets(0,0); }
});

/* speed limit */
let maxLimit = parseInt(speedLimitInput.value,10) || 255;
speedLimitVal.textContent = maxLimit;
speedLimitInput.addEventListener('input', ()=>{
  maxLimit = parseInt(speedLimitInput.value,10);
  speedLimitVal.textContent = maxLimit;
});

/* internal state for smoothing */
let targetLeft = 0, targetRight = 0;   // signed -255..255
let currentLeft = 0, currentRight = 0; // signed -255..255

// smoothing parameters
const TICK_MS = 60;          // smoothing tick
const MAX_STEP = 20;         // max change per tick (bigger = more responsive, smaller = smoother)
const PUBLISH_EPS = 2;       // minimum delta to publish again

// publish function: JSON structure described below
function sendPWMPayload(leftPWM, rightPWM, leftDir, rightDir, force=false){
  // leftPWM/rightPWM are unsigned 0..255; leftDir/rightDir in {1, -1, 0}
  const payload = JSON.stringify({
    left: leftPWM,
    right: rightPWM,
    leftDir: leftDir,
    rightDir: rightDir
  });
  if(client && client.connected){
    client.publish('car/speed', payload);
  }
  console.log('PUB car/speed ->', payload);
}

/* internal helper to compute signed motor values from throttle/steer */
function computeTankFromThrottleSteer(throttle, steer){
  // throttle: -1..1 (forward positive)
  // steer: -1..1 (left negative, right positive)
  // Basic mix:
  // left = throttle + steer
  // right = throttle - steer
  // Clamp result to -1..1 then scale to maxLimit
  let L = throttle + steer;
  let R = throttle - steer;
  // clamp magnitude to within [-1,1] preserving sign
  const maxMag = Math.max(Math.abs(L), Math.abs(R), 1);
  if(maxMag > 1){ L /= maxMag; R /= maxMag; }
  const scale = maxLimit / 255; // limit factor applied to final value
  L = Math.round(L * 255 * scale);
  R = Math.round(R * 255 * scale);
  // clamp signed
  L = Math.max(-255, Math.min(255, L));
  R = Math.max(-255, Math.min(255, R));
  return {L, R};
}

/* set target signed values (internal) */
function setJoystickTargets(signedLeft, signedRight){
  targetLeft = signedLeft;
  targetRight = signedRight;
}

/* create nipple joysticks */
function initJoysticks(){
  if(joystickLeft) return; // already created
  // left joystick - static, center in zone
  joystickLeft = nipplejs.create({
    zone: document.getElementById('joystick-left'),
    mode: 'static',
    position: { left: '50%', top: '50%' },
    color: '#4CAF50',
    size: 140
  });
  joystickRight = nipplejs.create({
    zone: document.getElementById('joystick-right'),
    mode: 'static',
    position: { left: '50%', top: '50%' },
    color: '#2196F3',
    size: 140
  });

  // left: use vertical axis for throttle
  joystickLeft.on('start', ()=>{/* noop */});
  joystickLeft.on('move', (evt, data) => {
    const angle = data.angle ? data.angle.radian : 0;
    const force = data.force || 0;
    // nipplejs: angle 90deg up = 90 -> degree 90; but we'll use vector y
    // data.vector.y is -1..1? More reliable to use data.distance / size
    const maxDistance = (data.instance.options.size || 140) / 2;
    // compute normalized axis: use dy from center (positive up)
    // data.angle.degree: 0 right, 90 up, 180 left, 270 down
    // compute throttle by projecting to vertical
    const deg = data.angle ? data.angle.degree : 0;
    // convert degree to vertical in -1..1
    let throttle = 0;
    if(force > 0.15){
      // use sin of degree to get vertical component (-1..1)
      const rad = deg * Math.PI / 180;
      throttle = Math.sin(rad); // up -> +1, down -> -1
    } else throttle = 0;
    // set target by recomputing tank mix with current steering target
    const steerNormalized = currentSteer || 0; // use last-known steering when adjusting
    const {L, R} = computeTankFromThrottleSteer(throttle, steerNormalized);
    setJoystickTargets(L, R);
  });
  joystickLeft.on('end', ()=> {
    // stop throttle (stop-on-release)
    setJoystickTargets(0, targetRight); // set left/right properly; steering remains
    // if steering also not pressed, overall targets zero â€” handled by smoother
    // we'll also zero steering if both ended
    // For simplicity, if both joysticks released, set both 0 (we detect via flags)
    leftReleased = true;
    if(rightReleased) setJoystickTargets(0,0);
  });

  // right: steering - horizontal axis (-1 left, +1 right)
  joystickRight.on('start', ()=>{/* noop */});
  joystickRight.on('move', (evt, data) => {
    const deg = data.angle ? data.angle.degree : 0;
    const force = data.force || 0;
    let steer = 0;
    if(force > 0.15){
      const rad = deg * Math.PI / 180;
      // horizontal component = cos(rad)
      steer = Math.cos(rad); // right -> +1, left -> -1
    } else steer = 0;
    currentSteer = steer;
    // existing throttle: estimate from target values (since targetLeft/Right hold last set)
    // compute throttle by averaging signs of current target
    const approxThrottle = (targetLeft + targetRight) / (2*255); // -1..1 approx
    const {L, R} = computeTankFromThrottleSteer(approxThrottle, steer);
    setJoystickTargets(L, R);
  });
  joystickRight.on('end', ()=> {
    // stop steering (stop-on-release)
    currentSteer = 0;
    rightReleased = true;
    if(leftReleased) setJoystickTargets(0,0);
    // if throttle still active, steering ended -> set steer 0
    const approxThrottle = (targetLeft + targetRight) / (2*255);
    const {L,R} = computeTankFromThrottleSteer(approxThrottle, 0);
    setJoystickTargets(L,R);
  });

  //	flags for end detection
  leftReleased = false;
  rightReleased = false;
  currentSteer = 0;
}

/* joystick state flags */
let leftReleased = true, rightReleased = true, currentSteer = 0;

/* also allow touch dragging on right zone to behave as steering-only vertical deadzone handled above */

/* ============================
   Smoothing loop - interpolate current -> target
   and publish whenever change above threshold or forced stop
   ============================ */
let lastPublishedLeft = 0, lastPublishedRight = 0;
setInterval(()=> {
  // move currentLeft toward targetLeft
  if(Math.abs(targetLeft - currentLeft) <= MAX_STEP) currentLeft = targetLeft;
  else currentLeft += (targetLeft > currentLeft) ? MAX_STEP : -MAX_STEP;

  if(Math.abs(targetRight - currentRight) <= MAX_STEP) currentRight = targetRight;
  else currentRight += (targetRight > currentRight) ? MAX_STEP : -MAX_STEP;

  // if small differences, snap to exact
  if(Math.abs(currentLeft) < 1) currentLeft = 0;
  if(Math.abs(currentRight) < 1) currentRight = 0;

  // prepare unsigned PWM + dir values for payload (dir: 1 forward, -1 backward, 0 stop)
  const leftDir = (currentLeft > 0) ? 1 : (currentLeft < 0 ? -1 : 0);
  const rightDir = (currentRight > 0) ? 1 : (currentRight < 0 ? -1 : 0);
  const leftAbs = Math.min(255, Math.abs(Math.round(currentLeft)));
  const rightAbs = Math.min(255, Math.abs(Math.round(currentRight)));

  // update UI
  leftPWMTxt.textContent = `${leftAbs} (${leftDir})`;
  rightPWMTxt.textContent = `${rightAbs} (${rightDir})`;

  // publish only if significant change
  if(Math.abs(leftAbs - lastPublishedLeft) > PUBLISH_EPS || Math.abs(rightAbs - lastPublishedRight) > PUBLISH_EPS){
    sendPWMPayload(leftAbs, rightAbs, leftDir, rightDir, false);
    lastPublishedLeft = leftAbs; lastPublishedRight = rightAbs;
  }
}, TICK_MS);

/* immediate publisher for forced stop */
function sendPWMPayload(leftPWM, rightPWM, leftDir, rightDir, force=false){
  // ensure numeric bounds
  leftPWM = Math.max(0,Math.min(255,Math.round(leftPWM)));
  rightPWM = Math.max(0,Math.min(255,Math.round(rightPWM)));
  leftDir = leftDir || 0; rightDir = rightDir || 0;

  const payload = JSON.stringify({ left:leftPWM, right:rightPWM, leftDir:leftDir, rightDir:rightDir });
  if(client && client.connected) client.publish('car/speed', payload);
  // Also update lastPublished to avoid double publishes
  lastPublishedLeft = leftPWM; lastPublishedRight = rightPWM;
  console.log('PUB car/speed ->', payload);
}

/* expose a simple function to convert raw throttle/steer (-1..1) to target signed left/right */
function applyThrottleSteer(throttleNorm, steerNorm){
  const {L,R} = computeTankFromThrottleSteer(throttleNorm, steerNorm);
  setJoystickTargets(L, R);
}

/* If user wants to send direct numeric speed via slider drag only (as fallback) */
speedLimitInput.addEventListener('change', ()=>{
  // slider sets limit only; don't publish extra commands here
});

/* ============================
   Stop-on-release / safety
   ============================ */
// When both joysticks end we already call setJoystickTargets(0,0). Additionally provide explicit stop on mouseup anywhere when joystick active
document.addEventListener('mouseup', ()=>{
  if(joystickActive){
    // give slight delay to avoid blocking tiny taps
    setTimeout(()=>{
      if(leftReleased && rightReleased){
        setJoystickTargets(0,0);
      }
    }, 80);
  }
});
document.addEventListener('touchend', ()=>{
  if(joystickActive){
    setTimeout(()=>{ if(leftReleased && rightReleased) setJoystickTargets(0,0); }, 80);
  }
});

/* ============================
   Initialize default UI
   ============================ */
speedLimitVal.textContent = speedLimitInput.value;
leftPWMTxt.textContent = '0 (0)';
rightPWMTxt.textContent = '0 (0)';
document.getElementById('modeToggle').click(); // start with joystick mode OFF (click toggles) -> ensures joysticks not created until user toggles

</script>
</body>
</html>
